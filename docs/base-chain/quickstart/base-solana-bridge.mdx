---
title: "Мост Base-Solana"
description: "Мост для токенов и сообщений между Base и Solana"
icon: "bridge"
---

import { GithubRepoCard } from "/snippets/GithubRepoCard.mdx"

<Warning>
  Мост Base-Solana сейчас работает только в тестнете (Base Sepolia ↔ Solana Devnet)..
</Warning>

Мост Base–Solana предоставляет двусторонние переводы токенов и передачу сообщений между сетями Base и Solana. С его помощью можно:

* **Отправлять токены** между Base и Solana
* **Отправлять произвольные кроссчейн-сообщения**
* **Комбинировать перевод и вызов функций**
* **Развёртывать врапнутые токены** на любой из сетей

Руководство объясняет архитектуру бриджа и содержит практические примеры реализации.

## Как это работает

### В сети Base
Контракт моста на Base блокирует или сжигает токены, когда сообщение отправляется в Solana,
и минтит или разблокирует токены, когда сообщение приходит из Solana.
Сам контракт бриджа строит Merkle-дерево для исходящих сообщений.
Валидаторы проверяют Merkle root каждые 300 финализированных блоков и отправляют его в Solana.
Затем вы доказываете, что ваше сообщение существует в `tree`, чтобы завершить перевод на Solana.

<Info>
Tokens that are native to Base are locked and tokens that are native to Solana are burned when bridging to Solana. При переводе в Solana токены, нативные для Base(ETH), блокируются, а нативные для Solana(SOL) - сжигаются.
При переносе в Base токены, нативные для Solana - минтятся, а нативные токены Base - разблокируются.
</Info>

**Основные смарт-контракты:**
- [**Bridge Contract**](https://github.com/base/bridge/blob/main/base/src/Bridge.sol): обрабатывает исходящие переводы
- [**CrossChainERC20**](https://github.com/base/bridge/blob/main/base/src/CrossChainERC20.sol): токены, которые можно минтить/сжигать при кроссчейн-переводах
- [**BridgeValidator**](https://github.com/base/bridge/blob/main/base/src/BridgeValidator.sol): проверяет сообщения по подписям валидаторов
- [**Twin Contract**](https://github.com/base/bridge/blob/main/base/src/Twin.sol): ваш персональный контракт на Base, в котором выполняются вызовы с Solana

<Tip>
**Что такое Twin Contract?**
Twin Contract - это смарт-контракт на Base, который действует как ваш `msg.sender`, когда вы отправляете произвольный вызов контракта из Solana.
</Tip>

### В сети Solana
Мост на Solana обрабатывает переводы токенов, блокируя или сжигая их. Для сообщений валидаторы передают их в Base, где они выполняются через персональный Twin Contract.

**Основные Solana-программы:**
- [**Bridge Program**](https://github.com/base/bridge/blob/main/solana/programs/bridge): обрабатывает исходящие трансферы
- [**Base Relayer Program**](https://github.com/base/bridge/blob/main/solana/programs/base_relayer): координирует передачу сообщений (не часть ядра бриджа)

Полный репозиторий:
<GithubRepoCard title="Base Bridge - Official Repository" githubUrl="https://github.com/base/bridge" />

<Info>
Программа relayer’а — это дополнительный модуль, не обязательный для работы моста. Она просто облегчает процесс передачи сообщений Solana → Base.
</Info>

## Потоки работы моста

<CardGroup cols={3}>
  <Card title="Solana → Base" icon="arrow-right" href="#solana-to-base">
    Автоматическая система ретрансляции для бесшовных переводов
  </Card>

  <Card title="Base → Solana" icon="arrow-left" href="#base-to-solana">
    Ручные переводы на основе доказательств с полным контролем
  </Card>

  <Card title="Полный Full Stack пример" icon="code" href="#sol2base%3A-full-stack-example">
    Полноценное приложение с интеграцией фронтенда
  </Card>
</CardGroup>

## Solana → Base

**Процесс:** Блокировка SOL → Ожидание предварительного одобрения валидаторами → Выполнение на Base

Мост Solana → Base использует pull-based модель, которая включает 3 шага:

1. **Инициация моста в Solana** - заблокируйте свои SOL или нативный SPL-токен в Solana vault.
2. **Ожидание предварительного одобрения сообщения валидаторами** - валидаторы проверяют и подтверждают ваш перевод.
3. **Выполнение перевода на Base** - подтверждённый перевод выполняется на Base для минта SOL и выполнения любых дополнительных произвольных вызовов.

<Info>
Токены, нативные для Solana, блокируются, а токены, нативные для Base, сжигаются при отправке в Solana. 
Токены, нативные для Base, минтятся, а токены, нативные для Solana, разблокируются при отправке в Base.
</Info>

Для удобства доступен relayer-сервис, который автоматически выполняет шаг 3 для пользователей, желающих заботиться только об исходной транзакции в Solana. Это обеспечивает максимально плавный опыт работы с мостом при сохранении безопасности pull-based модели.

<GithubRepoCard title="Solana to Base Relay Script" githubUrl="https://github.com/base/bridge/blob/main/scripts/src/commands/sol/onchain/bridge/solana-to-base/bridge-sol.handler.ts" />

### Пример авто-релея
Это пример скрипта, который показывает, как отправлять SOL через мост с авто-релеем.

```typescript solToBaseWithAutoRelay/index.ts expandable
// Configure
const TO = "0x8c1a617bdb47342f9c17ac8750e0b070c372c721"; // Base address
const AMOUNT = 0.001; // SOL amount

// Bridge SOL with auto-relay
const ixs = [
  getBridgeSolInstruction({
    payer,
    from: payer,
    solVault: solVaultAddress,
    bridge: bridgeAccountAddress,
    outgoingMessage,
    to: toBytes(TO),
    remoteToken: toBytes("0xC5b9112382f3c87AFE8e1A28fa52452aF81085AD"), // SOL on Base
    amount: BigInt(AMOUNT * 10**9),
  }),
  await buildPayForRelayIx(RELAYER_PROGRAM_ID, outgoingMessage, payer)
];

await buildAndSendTransaction(SOLANA_RPC_URL, ixs, payer);
```

Подробнее см. в разделе [Solana to Base Relay Script](https://github.com/base/bridge/blob/main/scripts/src/commands/sol/onchain/bridge/solana-to-base/bridge-sol.handler.ts).

### Обертка кастомных SPL-токенов

Пример выше показывает, как отправлять через мост нативный SOL на Base.
Чтобы отправлять кастомные SPL-токены, нужно создать их обертку ERC20-представления на Base, используя CrossChainERC20Factory.

<GithubRepoCard title="Token Wrapping Example" githubUrl="https://github.com/base/bridge/blob/main/scripts/src/commands/sol/onchain/bridge/solana-to-base/wrap-token.handler.ts" />

```typescript wrapSolTokenOnBase/index.ts expandable
// Deploy wrapped token on Base
const mintBytes32 = getBase58Codec().encode(SOLANA_SPL_MINT_ADDRESS).toHex();

await client.writeContract({
  address: "0x58207331CBF8Af87BB6453b610E6579D9878e4EA", // Factory
  abi: TokenFactory,
  functionName: "deploy",
  args: [`0x${mintBytes32}`, "Token Name", "SYMBOL", 9],
});
```

## Base → Solana

**Процесс:** Сжигание SOL (на Base) → ожидание ~15 минут → генерация proof → выполнение на Solana

Отправка SOL через мост из Base в Solana требует ручной генерации доказательства.
Вы сжигаете обернутый SOL на Base, ждёте финализации, затем создаёте криптографическое доказательство, чтобы выполнить транзакцию на Solana и получить нативный SOL.

<GithubRepoCard title="Base to Solana Example" githubUrl="https://github.com/base/bridge/blob/main/scripts/src/internal/sol/base.ts" />


```typescript bridgeSolFromBaseToSolana/index.ts expandable
// Step 1: Burn SOL on Base
const transfer = {
  localToken: "0xC5b9112382f3c87AFE8e1A28fa52452aF81085AD", // SOL (on Base)
  remoteToken: pubkeyToBytes32(SOL_ADDRESS),
  to: pubkeyToBytes32(solanaAddress),
  remoteAmount: BigInt(AMOUNT * 10**9),
};

const txHash = await client.writeContract({
  address: "0xB2068ECCDb908902C76E3f965c1712a9cF64171E", // Bridge
  abi: Bridge,
  functionName: "bridgeToken",
  args: [transfer, []],
});

// Step 2: Wait for finalization
const isProvable = await isBridgeMessageProvable(txHash);

// Step 3: Generate proof
const { event, rawProof } = await generateProof(txHash, baseBlockNumber);

// Step 4: Execute on Solana
const proveIx = getProveMessageInstruction({
  nonce: event.message.nonce,
  sender: toBytes(event.message.sender),
  data: toBytes(event.message.data),
  proof: rawProof.map(e => toBytes(e)),
  messageHash: toBytes(event.messageHash),
});

const relayIx = getRelayMessageInstruction({ message: messagePda });
await buildAndSendTransaction(SOLANA_RPC_URL, [proveIx, relayIx], payer);
```

## Утилити

Репозиторий содержит утилити для конвертации адресов между форматами Solana и Base, получения ключей из Solana CLI для подписания транзакций, а также для сборки и отправки Solana-транзакций.

<GithubRepoCard title="Base Bridge Examples - Utilities" githubUrl="https://github.com/base/bridge/tree/main/scripts/src/commands" />

### Конвертация адресов

Конвертация Solana pubkey в bytes32 для контрактов Base:
```typescript example.ts
// Convert Solana pubkey to bytes32 for Base contracts
import { pubkeyToBytes32 } from "./utils/pubkeyToBytes32";

const bytes32Address = pubkeyToBytes32(solanaAddress);
```

### Управление ключами

Получение ключей из Solana CLI для подписания транзакций:

```typescript example.ts
import { getSolanaCliConfigKeypairSigner } from "./utils/keypair";

const payer = await getSolanaCliConfigKeypairSigner();
```

### Сборка транзакций

Сборка и отправка Solana-транзакций:

```typescript example.ts
import { buildAndSendTransaction } from "./utils/buildAndSendTransaction";

const signature = await buildAndSendTransaction(SOLANA_RPC_URL, ixs, payer);
```

## Sol2Base: Full Stack Пример

<GithubRepoCard title="Sol2Base - Full Stack Bridge App" githubUrl="https://github.com/base/sol2base" />

Sol2Base - это готовое к продакшену приложение на Next.js, которое показывает, как создать полноценный фронтенд для моста между Base и Solana. В нём используется «хакерская» стилистика с анимациями в духе «Матрицы». Приложение поддерживает подключение кошельков, CDP faucet, разрешение ENS/Basename и мониторинг транзакций в реальном времени.

### Bridge Service Implementation

!!!!!Остановился здесь!!!!!

```typescript src/lib/bridge.ts expandable
export class SolanaBridge {
  private connection: Connection;

  constructor() {
    this.connection = new Connection(SOLANA_DEVNET_CONFIG.rpcUrl, 'confirmed');
  }

  async createBridgeTransaction(
    walletAddress: PublicKey,
    amount: number,
    destinationAddress: string,
    signTransaction: (transaction: Transaction) => Promise<Transaction>
  ): Promise<string> {
    // Import address resolver and real bridge
    const { addressResolver } = await import('./addressResolver');
    const { realBridgeImplementation } = await import('./realBridgeImplementation');
    
    // Resolve destination address (handles ENS/basename)
    const resolvedAddress = await addressResolver.resolveAddress(destinationAddress);

    // Validate amount
    if (amount < BRIDGE_CONFIG.minBridgeAmount / Math.pow(10, 9)) {
      throw new Error(`Minimum bridge amount is ${BRIDGE_CONFIG.minBridgeAmount / Math.pow(10, 9)} SOL`);
    }

    // Create the real bridge transaction
    const transaction = await realBridgeImplementation.createBridgeTransaction(
      walletAddress,
      amount,
      resolvedAddress
    );

    // Submit the transaction
    const signature = await realBridgeImplementation.submitBridgeTransaction(
      transaction,
      walletAddress,
      signTransaction
    );

    return signature;
  }
}
```
### Address Resolution Service

Supports ENS names and Basenames for user-friendly addressing:

```typescript src/lib/addressResolver.ts expandable
export class AddressResolver {
  async resolveAddress(input: string): Promise<string> {
    const trimmedInput = input.trim();

    // If it's already a valid Ethereum address, return as-is
    if (this.isValidEthereumAddress(trimmedInput)) {
      return trimmedInput;
    }

    // Handle ENS names (.eth)
    if (trimmedInput.endsWith('.eth') && !trimmedInput.endsWith('.base.eth')) {
      return await this.resolveEns(trimmedInput);
    }

    // Handle basenames (.base.eth or .base)
    if (trimmedInput.endsWith('.base.eth') || trimmedInput.endsWith('.base')) {
      return await this.resolveBasename(trimmedInput);
    }

    throw new Error('Invalid address format');
  }

  private async resolveEns(ensName: string): Promise<string> {
    const response = await fetch(`https://api.ensdata.net/${ensName}`);
    const data = await response.json();
    
    if (!data.address) {
      throw new Error(`ENS name ${ensName} does not resolve to an address`);
    }

    return data.address;
  }
}
```

### React Bridge Interface

Complete UI component with wallet integration and form validation:

```typescript src/components/BridgeInterface.tsx expandable
export const BridgeInterface: React.FC = () => {
  const { publicKey, connected, signTransaction } = useWallet();
  const [solBalance, setSolBalance] = useState<number>(0);
  const [transactions, setTransactions] = useState<BridgeTransaction[]>([]);

  // Handle bridge transaction
  const handleBridge = async (amount: number, destinationAddress: string) => {
    if (!publicKey || !signTransaction) {
      setError('Wallet not connected');
      return;
    }

    try {
      const txHash = await solanaBridge.createBridgeTransaction(
        publicKey, 
        amount, 
        destinationAddress,
        signTransaction
      );

      // Add to transaction history
      const newTransaction: BridgeTransaction = {
        txHash,
        amount,
        destinationAddress,
        status: 'confirmed',
        timestamp: Date.now(),
        type: 'bridge'
      };

      setTransactions(prev => [newTransaction, ...prev]);
      await loadBalances();

    } catch (err) {
      setError(err instanceof Error ? err.message : 'Bridge transaction failed');
    }
  };

  return (
    <div className="max-w-4xl mx-auto space-y-8">
      <BalanceDisplay solBalance={solBalance} />
      <FaucetButton onFaucet={handleSolFaucet} />
      <BridgeForm onBridge={handleBridge} maxAmount={solBalance} />
      <TransactionStatus transactions={transactions} />
    </div>
  );
};
```

### Bridge Form with Address Resolution

Smart form component with ENS/Basename support and validation:

```typescript src/components/BridgeForm.tsx expandable
export const BridgeForm: React.FC<BridgeFormProps> = ({ onBridge, maxAmount }) => {
  const [amount, setAmount] = useState<string>('');
  const [destinationAddress, setDestinationAddress] = useState<string>('');
  const [resolvedAddress, setResolvedAddress] = useState<string>('');
  const [isResolvingAddress, setIsResolvingAddress] = useState<boolean>(false);

  // Debounced address resolution
  const resolveAddress = useCallback(async (address: string) => {
    if (!address.trim()) return;

    setIsResolvingAddress(true);
    try {
      const type = addressResolver.getInputType(address);
      
      if (type === 'Ethereum Address') {
        setResolvedAddress(address);
      } else {
        const resolved = await addressResolver.resolveAddress(address);
        setResolvedAddress(resolved);
      }
    } catch (error) {
      setErrors(prev => ({ 
        ...prev, 
        address: error instanceof Error ? error.message : 'Failed to resolve address'
      }));
    } finally {
      setIsResolvingAddress(false);
    }
  }, []);

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="number"
        value={amount}
        onChange={(e) => setAmount(e.target.value)}
        placeholder="Enter SOL amount"
      />
      
      <input
        type="text"
        value={destinationAddress}
        onChange={(e) => setDestinationAddress(e.target.value)}
        placeholder="0x..., Basename, or ENS"
      />
      
      {resolvedAddress && resolvedAddress !== destinationAddress && (
        <div className="resolved-address">
          ✓ Resolved to: {resolvedAddress}
        </div>
      )}
      
      <button type="submit" disabled={!amount || !resolvedAddress}>
        Bridge to Base
      </button>
    </form>
  );
};
```

### Setup and Development

```bash Terminal expandable
# Clone and setup
git clone https://github.com/base/sol2base.git
cd sol2base
npm install --legacy-peer-deps

# Environment setup
cp env.template .env.local
# Add Coinbase Developer Platform (CDP) API credentials for faucet (optional)

# Start development server
npm run dev
# Open http://localhost:3000
```

<Tip>
**Get your Coinbase Developer Platform (CDP) API credentials from the [the portal](https://portal.cdp.coinbase.com/projects/api-keys/client-key).**

The example above uses the Coinbase Developer Platform faucet for SOL.
To get access to the faucet API, you can follow the instructions [here](https://docs.cdp.coinbase.com/faucets/introduction/welcome).
</Tip>

## Contract Addresses

### Base Sepolia

```json
{
  "Bridge": "0xB2068ECCDb908902C76E3f965c1712a9cF64171E",
  "CrossChainERC20Factory": "0x58207331CBF8Af87BB6453b610E6579D9878e4EA",
  "WrappedSOL": "0xC5b9112382f3c87AFE8e1A28fa52452aF81085AD"
}
```

### Solana Devnet

```json
{
  "BridgeProgram": "HSvNvzehozUpYhRBuCKq3Fq8udpRocTmGMUYXmCSiCCc",
  "BaseRelayerProgram": "ExS1gcALmaA983oiVpvFSVohi1zCtAUTgsLj5xiFPPgL"
}
```

## Troubleshooting

<AccordionGroup>
  <Accordion title="Transaction failed on Base">
    * Ensure sufficient ETH for gas fees
    * For ERC20 tokens, approve the bridge contract first using `approve()`
    * Verify token addresses are correct and match the expected format
    * Check that your private key is correctly set in the `.env` file
  </Accordion>

  <Accordion title="Message not appearing on Solana">
    * Wait at least 15 minutes for message relay
    * Check that your Base transaction was successful and included a `MessageRegistered` event
    * Verify you're using the correct network (testnet/devnet)
    * Ensure the Solana bridge has processed the Base block number
  </Accordion>

  <Accordion title="Proof verification failed">
    * Ensure you're using the latest Base block number from the Solana bridge
    * Verify the message hash matches the original transaction
    * Check that the proof was generated at the correct block height
    * Make sure all account addresses are correctly derived
  </Accordion>

  <Accordion title="Auto-relay not working">
    * Verify you have sufficient SOL to pay for relay fees
    * Check that the Base Relayer program is properly configured
    * Ensure the outgoing message was created successfully
    * Monitor both Solana and Base explorers for transaction status
  </Accordion>
</AccordionGroup>

## Security

<Warning>
  **Important Security Notes:**

  * Only use testnet funds (Solana devnet SOL and Base Sepolia ETH)
  * Validate all addresses before bridging
  * Monitor transactions on both chains
  * Keep your private keys secure and never share them
</Warning>

## Resources

<CardGroup cols={2}>
  <Card title="GitHub Repository" icon="github" href="https://github.com/base/bridge">
    View source code and examples
  </Card>

  <Card title="Solana Explorer" icon="magnifying-glass" href="https://explorer.solana.com/?cluster=devnet">
    Monitor Solana devnet transactions
  </Card>

  <Card title="Base Sepolia Explorer" icon="magnifying-glass" href="https://sepolia.basescan.org/">
    Monitor Base Sepolia transactions
  </Card>

  <Card title="Discord Support" icon="discord" href="https://base.org/discord">
    Get help from the community
  </Card>
</CardGroup>
