---
title: 'Использование суб-аккаунтов'
description: 'Узнайте, как создавать и использовать суб-аккаунты с помощью SDK Base Account'
---

import { GithubRepoCard } from "/snippets/GithubRepoCard.mdx"

## Что такое суб-аккаунты?

Суб-аккаунты (Sub Accounts) позволяют создавать для ваших пользователей специфичные для приложения кошельки, которые встроены непосредственно в ваше приложение. После создания вы можете взаимодействовать с ними так же, как и с любым другим кошельком, через провайдер кошелька или популярные ончейн-библиотеки, такие как OnchainKit, wagmi и viem.

<Note>
Ищете полную реализацию? Перейдите к [Complete Integration Example](/base-account/improve-ux/sub-accounts#complete-integration-example).
</Note>

## Ключевые преимущества

- **Беспрепятственные транзакции**: Устраните повторяющиеся запросы на подпись для сценариев с высокой частотой операций или автономных агентов (AI agents) или возьмите полный контроль над процессом транзакции.
- **Не требуются пополнения**: Разрешения на расходование (Spend Permissions) позволяют суб-аккаунтам тратить средства напрямую с баланса универсального Base Account пользователя.
- **Контроль со стороны пользователя**: Пользователи могут управлять всеми своими суб-аккаунтами на [account.base.app](https://account.base.app).

<Note>
Если вы хотите увидеть живую демонстрацию работы суб-аккаунтов, ознакомьтесь с нашим [Sub Accounts Demo](https://sub-accounts-fc.vercel.app).
</Note>

<Tip>
**Spend Permissions** 

Суб-аккаунты оптимизированы для использования вместе с Разрешениями на расходование (Spend Permissions), что позволяет вашему приложению использовать существующие балансы Base Account пользователя. Подробнее о том, как это работает, читайте в руководстве по [Spend Permissions](/base-account/improve-ux/spend-permissions).
</Tip>

## Установка

Установите SDK Base Account:

<CodeGroup>
```bash npm
npm install @base-org/account
```

```bash pnpm
pnpm add @base-org/account
```

```bash yarn
yarn add @base-org/account
```

```bash bun
bun add @base-org/account
```
</CodeGroup>

## Быстрый старт

Самый быстрый способ начать использовать суб-аккаунты - установить для параметров конфигурации SDK значения `creation`: `on-connect` и `defaultAccount`: `sub`.

```tsx
const sdk = createBaseAccountSDK({
  // ...
  subAccounts: {
    creation: 'on-connect',
    defaultAccount: 'sub',
  }
});
```

Это автоматически создаст суб-аккаунт для пользователя при подключении его Base Account, и транзакции будут автоматически отправляться с этого суб-аккаунта, если вы не укажете в запросе транзакции параметр `from` как адрес универсального аккаунта. Разрешения на расходование также будут автоматически запрашиваться для суб-аккаунта по мере необходимости вашему приложению.

Вот что увидит пользователь при подключении своего Base Account, когда включены автоматические суб-аккаунты:

<div style={{ display: 'flex', justifyContent: 'center'}}>
  <img src="/images/base-account/SubAccountCreationConnect.png" alt="Sub Account Creation Flow" style={{ width: '300px', height: 'auto' }} />
</div>

<Tip>
Мы рекомендуем использовать [Paymaster](/base-account/improve-ux/sponsor-gas/paymasters) для спонсирования комиссий, чтобы обеспечить наилучший пользовательский опыт при интеграции суб-аккаунтов. Вы можете настроить paymaster для использования во всех транзакциях, указав параметр `paymasterUrls` в конфигурации SDK. Подробнее см. в справочнике по [createBaseAccount](/base-account/reference/core/createBaseAccount#param-paymaster-urls).
</Tip>

## Использование суб-аккаунтов

### Инициализация SDK

Сначала настройте SDK Base Account. Обязательно укажите `appName` и `appLogoUrl`, соответствующие вашему приложению, так как они будут отображаться во всплывающем окне подключения кошелька и в панели управления account.base.app. Вы также можете настроить `appChainIds` на цепи, которые поддерживает ваше приложение.

```tsx
import { createBaseAccountSDK, getCryptoKeyAccount } from '@base-org/account';
import { base } from 'viem/chains';

// Инициализация SDK с конфигурацией суб-аккаунта
const sdk = createBaseAccountSDK({
  appName: 'Base Account SDK Demo',
  appLogoUrl: 'https://base.org/logo.png',
  appChainIds: [base.id],
});

// Получить провайдер EIP-1193
const provider = sdk.getProvider()
```

### Создание суб-аккаунта

<Tip>
Убедитесь, что пользователь аутентифицирован с помощью своего Base Account перед созданием суб-аккаунта.
Для этого вы можете выбрать один из следующих вариантов:
- Следуйте руководству [Authenticate users](/base-account/guides/authenticate-users)
- Или просто используйте `provider.request({ method: 'eth_requestAccounts' });` для простого подключения кошелька
</Tip>

Создайте суб-аккаунт для вашего приложения, используя RPC-метод провайдера [wallet_addSubAccount](/base-account/reference/core/provider-rpc-methods/wallet_addSubAccount). Когда параметр `publicKey` не указан, генерируется неизвлекаемый ключ браузера (CryptoKey), который используется для подписи от имени суб-аккаунта.

```tsx
// Создать суб-аккаунт
const subAccount = await provider.request({
  method: 'wallet_addSubAccount',
  params: [
    {
      account: {
        type: 'create',
      },
    }
  ],
});

console.log('Sub Account created:', subAccount.address);
```

Альтернативно, вы можете использовать удобный метод SDK:

```tsx
const subAccount = await sdk.subAccount.create();

console.log('Sub Account created:', subAccount.address);
```

Вот что увидит пользователь при запросе на создание суб-аккаунта:

<div style={{ display: 'flex', justifyContent: 'center'}}>
  <img src="/images/base-account/SubAccountCreation.png" alt="Sub Account Creation Flow" style={{ width: '300px', height: 'auto' }} />
</div>

### Получение существующего суб-аккаунта

Получите существующий суб-аккаунт, используя RPC-метод провайдера [wallet_getSubAccounts](/base-account/reference/core/provider-rpc-methods/wallet_getSubAccounts). Это вернет суб-аккаунт, связанный с доменом приложения, и полезно для проверки существования суб-аккаунта у пользователя, чтобы определить, нужно ли его создавать.

```tsx
// Получить универсальный аккаунт
const [universalAddress] = await provider.request({
  method: "eth_requestAccounts",
  params: []
})

// Получить суб-аккаунт для универсального аккаунта
const { subAccounts: [subAccount] } = await provider.request({
  method: 'wallet_getSubAccounts',
  params: [{
    account: universalAddress,
    domain: window.location.origin,
  }]
})

if (subAccount) {
  console.log('Sub Account found:', subAccount.address);
} else {
  console.log('No Sub Account exists for this app');
}
```

Альтернативно, вы можете использовать удобный метод SDK:

```tsx
const subAccount = await sdk.subAccount.get();

console.log('Sub Account:', subAccount);
```
### Отправка транзакций

Чтобы отправлять транзакции с подключенного суб-аккаунта, вы можете использовать `wallet_sendCalls` (EIP-5792) или `eth_sendTransaction`. Вам необходимо указать параметр `from` как адрес суб-аккаунта.

<Tip>
Когда суб-аккаунт подключен, он является вторым аккаунтом в массиве, возвращаемом `eth_requestAccounts` или `eth_accounts`. Метод `wallet_addSubAccount` необходимо вызывать в каждой сессии перед использованием суб-аккаунта. Это не вызовет новое создание суб-аккаунта, если он уже существует.

Если вы используете `mode: 'auto'`, суб-аккаунт будет первым аккаунтом в массиве.
</Tip>

Сначала получите все доступные аккаунты, где суб-аккаунт будет вторым:

```tsx
const [universalAddress, subAccountAddress] = await provider.request({
  method: "eth_requestAccounts", // или "eth_accounts", если уже подключен
  params: []
})
```

Затем отправьте транзакцию от имени суб-аккаунта:

**`wallet_sendCalls`**

```tsx
const callsId = await provider.request({
  method: 'wallet_sendCalls',
  params: [{
    version: "2.0",
    atomicRequired: true,
    from: subAccountAddress, // Указываем адрес суб-аккаунта
    calls: [{
      to: '0x...',
      data: '0x...',
      value: '0x...',
    }],
    capabilities: {
      // https://docs.cdp.coinbase.com/paymaster/introduction/welcome
      paymasterUrl: "https://...",
    },
  }]
})

console.log('Calls sent:', callsId);
```

**`eth_sendTransaction`**

```tsx
const tx = await provider.request({
  method: 'eth_sendTransaction',
  params: [{
    from: subAccountAddress, // Указываем адрес суб-аккаунта
    to: '0x...',
    data: '0x...',
    value: '0x...',
  }]
})

console.log('Transaction sent:', tx);
```

Мы рекомендуем использовать `wallet_sendCalls` вместе с paymaster для обеспечения наилучшего пользовательского опыта. Подробнее см. в руководстве по [Paymasters](/base-account/improve-ux/sponsor-gas/paymasters).

## Расширенное использование

### Импорт существующего аккаунта

Если у вас уже есть развернутый смарт-контракт аккаунт, и вы хотите сделать его суб-аккаунтом подключенного Base Account, вы можете импортировать его как суб-аккаунт, используя RPC-метод провайдера:

```tsx
const subAccount = await provider.request({
  method: 'wallet_addSubAccount',
  params: [
    {
      account: {
        type: 'deployed',
        address: '0xYourSmartContractAccountAddress',
        chainId: 8453 // цепь, на которой развернут аккаунт
      },
    }
  ],
});

console.log('Sub Account added:', subAccount.address);
```

<Note>

Перед импортом суб-аккаунта вам необходимо добавить адрес Base Account в качестве владельца (owner) суб-аккаунта. В настоящее время это необходимо делать вручную путем вызова функций [`addOwnerAddress`](https://github.com/coinbase/smart-wallet/blob/a8c6456f3a6d5d2dea08d6336b3be13395cacd42/src/MultiOwnable.sol#L101) или [`addOwnerPublicKey`](https://github.com/coinbase/smart-wallet/blob/a8c6456f3a6d5d2dea08d6336b3be13395cacd42/src/MultiOwnable.sol#L109) в смарт-контракте импортируемого суб-аккаунта, указав адрес Base Account в качестве владельца.

Кроме того, на данный момент только контракты Coinbase Smart Wallet поддерживаются для импорта в качестве суб-аккаунта в ваш Base Account.

ABI контракта Coinbase Smart Wallet можно найти на [GitHub](https://github.com/base/account-sdk/blob/master/packages/account-sdk/src/sign/base-account/utils/constants.ts#L8).
</Note>


### Добавление владельца (Owner) аккаунта

Суб-аккаунты автоматически обнаруживают необходимость обновления прав владения, когда требуется подпись, и запрашивают у пользователя подтверждение перед подписанием. Однако вы также можете добавить владельца к суб-аккаунту вручную, используя удобный метод SDK:

```tsx
const ownerAccount = await sdk.subAccount.addOwner({
  address: subAccount?.address,
  publicKey: cryptoAccount?.account?.publicKey,
  chainId: base.id,
});

console.log('Owner added to Sub Account');
```

Это создает транзакцию для вызова функций `addOwnerAddress` или `addOwnerPublicKey` в смарт-контракте суб-аккаунта, чтобы добавить владельца.

<Note>
Изменения прав владения ожидаемы, если пользователь входит в ваше приложение на новом устройстве или в другом браузере.

Убедитесь, что вы не теряете ключи для подписи суб-аккаунта вашего приложения при использовании SDK на сервере (например, Node.js), так как обновление владельца требует подписи от пользователя, которую нельзя запросить в серверном контексте.
</Note>

## Автоматические разрешения на расходование (Auto Spend Permissions)

Функция Auto Spend Permissions позволяет суб-аккаунтам получать доступ к средствам из их родительского Base Account, когда баланса суб-аккаунта недостаточно для транзакции. Эта функция также может устанавливать постоянные разрешения на расходование, позволяя выполнять будущие транзакции без запросов на подтверждение пользователя, что снижает трение в процессе транзакций вашего приложения.

Эта функция **включена по умолчанию** при использовании суб-аккаунтов.

### Как это работает

**Поток первой транзакции:**
Когда суб-аккаунт пытается совершить свою первую транзакцию, Base Account отображает всплывающее окно для подтверждения пользователем. В процессе этого подтверждения Base Account:

- Автоматически определяет отсутствующие токены (нативные или ERC-20), необходимые для транзакции
- Запрашивает перевод необходимых средств из родительского Base Account в суб-аккаунт для выполнения текущей транзакции
- Позволяет пользователю при желании предоставить постоянные разрешения на расходование для будущих транзакций в этом токене

**Последующие транзакции:**
Если пользователь предоставил разрешения на расходование, будущие транзакции следуют такому приоритету:

1. Сначала используется существующий баланс суб-аккаунта и предоставленные разрешения на расходование
2. Если средств недостаточно, пользователю предлагается авторизовать дополнительные переводы и/или разрешения на расходование со своего Base Account

<Warning>
Запросы на разрешение расходования ограничены первым токеном, когда для одной транзакции требуется несколько переводов. Для дополнительных токенов требуются отдельные разрешения.
</Warning>


### Конфигурация

Если суб-аккаунты ваших пользователей будут пополняться вручную, вы можете отключить Auto Spend Permissions, установив для параметра `funding` значение `manual` в конфигурации SDK:

```tsx
const sdk = createBaseAccountSDK({
  appName: 'Base Account SDK Demo',
  appLogoUrl: 'https://base.org/logo.png',
  appChainIds: [base.id],
  subAccounts: {
    funding: 'manual', // Отключить автоматические разрешения на расходование
  }
});
```


## Технические детали

Самокастодиальный дизайн Base Account требует запроса на подтверждение с помощью passkey для каждого взаимодействия с кошельком, такого как транзакции или подпись сообщений. Хотя это обеспечивает осведомленность и одобрение пользователем каждого действия, это может повлиять на пользовательский опыт в приложениях, требующих частых взаимодействий с кошельком.

Для поддержки Base Account в сценариях, где разработчикам требуется больший контроль над взаимодействиями с кошельком, мы создали суб-аккаунты совместно с [ERC-7895](https://eip.tools/eip/7895) - новым RPC-методом кошелька для создания иерархических отношений между аккаунтами кошельков.

Эти суб-аккаунты связаны с Base Account конечного пользователя через ончейн-отношения. В сочетании с нашей функцией [Spend Permission](/base-account/improve-ux/spend-permissions) это создает мощную основу для безопасного создания и финансирования аккаунтов приложений, предоставляя вам широкий контроль для создания оптимального пользовательского опыта.


## Пример полной интеграции

Вот полный React-компонент, демонстрирующий создание и использование суб-аккаунта:

```tsx
import { createBaseAccountSDK } from "@base-org/account";
import { useCallback, useEffect, useState } from "react";
import { baseSepolia } from "viem/chains";

interface SubAccount {
  address: `0x${string}`;
  factory?: `0x${string}`;
  factoryData?: `0x${string}`;
}

interface GetSubAccountsResponse {
  subAccounts: SubAccount[];
}

interface WalletAddSubAccountResponse {
  address: `0x${string}`;
  factory?: `0x${string}`;
  factoryData?: `0x${string}`;
}

export default function SubAccountDemo() {
  const [provider, setProvider] = useState<ReturnType<
    ReturnType<typeof createBaseAccountSDK>["getProvider"]
  > | null>(null);
  const [subAccount, setSubAccount] = useState<SubAccount | null>(null);
  const [universalAddress, setUniversalAddress] = useState<string>("");
  const [connected, setConnected] = useState(false);
  const [loadingSubAccount, setLoadingSubAccount] = useState(false);
  const [loadingUniversal, setLoadingUniversal] = useState(false);
  const [status, setStatus] = useState("");

  // Инициализация SDK и криптоаккаунта
  useEffect(() => {
    const initializeSDK = async () => {
      try {
        const sdkInstance = createBaseAccountSDK({
          appName: "Sub Account Demo",
          appChainIds: [baseSepolia.id],
        });

        // Получить провайдер
        const providerInstance = sdkInstance.getProvider();
        setProvider(providerInstance);

        setStatus("SDK initialized - ready to connect");
      } catch (error) {
        console.error("SDK initialization failed:", error);
        setStatus("SDK initialization failed");
      }
    };

    initializeSDK();
  }, []);

  const connectWallet = async () => {
    if (!provider) {
      setStatus("Provider not initialized");
      return;
    }

    setLoadingSubAccount(true);
    setStatus("Connecting wallet...");

    try {
      // Подключиться к кошельку
      const accounts = (await provider.request({
        method: "eth_requestAccounts",
        params: [],
      })) as string[];

      const universalAddr = accounts[0];
      setUniversalAddress(universalAddr);
      setConnected(true);

      // Проверить наличие существующего суб-аккаунта
      const response = (await provider.request({
        method: "wallet_getSubAccounts",
        params: [
          {
            account: universalAddr,
            domain: window.location.origin,
          },
        ],
      })) as GetSubAccountsResponse;

      const existing = response.subAccounts[0];
      if (existing) {
        setSubAccount(existing);
        setStatus("Connected! Existing Sub Account found");
      } else {
        setStatus("Connected! No existing Sub Account found");
      }
    } catch (error) {
      console.error("Connection failed:", error);
      setStatus("Connection failed");
    } finally {
      setLoadingSubAccount(false);
    }
  };

  const createSubAccount = async () => {
    if (!provider) {
      setStatus("Provider not initialized");
      return;
    }

    setLoadingSubAccount(true);
    setStatus("Creating Sub Account...");

    try {
      const newSubAccount = (await provider.request({
        method: "wallet_addSubAccount",
        params: [
          {
            account: {
              type: 'create',
            },
          }
        ],
      })) as WalletAddSubAccountResponse;

      setSubAccount(newSubAccount);
      setStatus("Sub Account created successfully!");
    } catch (error) {
      console.error("Sub Account creation failed:", error);
      setStatus("Sub Account creation failed");
    } finally {
      setLoadingSubAccount(false);
    }
  };

  const sendCalls = useCallback(
    async (
      calls: Array<{ to: string; data: string; value: string }>,
      from: string,
      setLoadingState: (loading: boolean) => void
    ) => {
      if (!provider) {
        setStatus("Provider not available");
        return;
      }

      setLoadingState(true);
      setStatus("Sending calls...");

      try {
        const callsId = (await provider.request({
          method: "wallet_sendCalls",
          params: [
            {
              version: "2.0",
              atomicRequired: true,
              chainId: `0x${baseSepolia.id.toString(16)}`, // Конвертировать в hex
              from,
              calls,
              capabilities: {
                // https://docs.cdp.coinbase.com/paymaster/introduction/welcome
                // paymasterUrl: "your paymaster url",
              },
            },
          ],
        })) as string;

        setStatus(`Calls sent! Calls ID: ${callsId}`);
      } catch (error) {
        console.error("Send calls failed:", error);
        setStatus("Send calls failed");
      } finally {
        setLoadingState(false);
      }
    },
    [provider]
  );

  const sendCallsFromSubAccount = useCallback(async () => {
    if (!subAccount) {
      setStatus("Sub account not available");
      return;
    }

    const calls = [
      {
        to: "0x4bbfd120d9f352a0bed7a014bd67913a2007a878",
        data: "0x9846cd9e", // yoink
        value: "0x0",
      },
    ];

    await sendCalls(calls, subAccount.address, setLoadingSubAccount);
  }, [sendCalls, subAccount]);

  const sendCallsFromUniversal = useCallback(async () => {
    if (!universalAddress) {
      setStatus("Universal account not available");
      return;
    }

    const calls = [
      {
        to: "0x4bbfd120d9f352a0bed7a014bd67913a2007a878",
        data: "0x9846cd9e", // yoink
        value: "0x0",
      },
    ];

    await sendCalls(calls, universalAddress, setLoadingUniversal);
  }, [sendCalls, universalAddress]);

  return (
    <div className="sub-account-demo">
      <h2>Sub Account Demo</h2>

      <div className="status">
        <p>
          <strong>Status:</strong> {status}
        </p>
        {universalAddress && (
          <p>
            <strong>Universal Account:</strong> {universalAddress}
          </p>
        )}
        {subAccount && (
          <p>
            <strong>Sub Account:</strong> {subAccount.address}
          </p>
        )}
      </div>

      <div className="actions">
        {!connected ? (
          <button
            onClick={connectWallet}
            disabled={loadingSubAccount || !provider}
            className="connect-btn"
          >
            {loadingSubAccount ? "Connecting..." : "Connect Wallet"}
          </button>
        ) : !subAccount ? (
          <button
            onClick={createSubAccount}
            disabled={loadingSubAccount}
            className="create-btn"
          >
            {loadingSubAccount ? "Creating..." : "Add Sub Account"}
          </button>
        ) : (
          <div>
            <button
              onClick={sendCallsFromSubAccount}
              disabled={loadingSubAccount}
              className="sub-account-btn"
            >
              {loadingSubAccount ? "Sending..." : "Send Calls from Sub Account"}
            </button>
            <button
              onClick={sendCallsFromUniversal}
              disabled={loadingUniversal}
              className="universal-btn"
            >
              {loadingUniversal
                ? "Sending..."
                : "Send Calls from Universal Account"}
            </button>
          </div>
        )}
      </div>

      <style jsx>{`
        .sub-account-demo {
          max-width: 600px;
          margin: 0 auto;
          padding: 20px;
          font-family: Arial, sans-serif;
        }

        .status {
          border-radius: 8px;
          margin: 20px 0;
        }

        .status p {
          margin: 5px 0;
        }

        .actions {
          margin: 20px 0;
        }

        .connect-btn,
        .create-btn,
        .sub-account-btn,
        .universal-btn {
          background: #0052ff;
          color: white;
          border: none;
          padding: 12px 24px;
          border-radius: 8px;
          cursor: pointer;
          font-size: 16px;
          margin-right: 15px;
          margin-bottom: 10px;
        }

        .connect-btn:disabled,
        .create-btn:disabled,
        .sub-account-btn:disabled,
        .universal-btn:disabled {
          background: #ccc;
          cursor: not-allowed;
        }

        .connect-btn:hover:not(:disabled),
        .create-btn:hover:not(:disabled),
        .sub-account-btn:hover:not(:disabled),
        .universal-btn:hover:not(:disabled) {
          background: #0041cc;
        }
      `}</style>
    </div>
  );
}
```
