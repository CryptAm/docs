### [Приложения Ethereum](/learn/introduction-to-ethereum/ethereum-applications)

- Описать происхождение и цели блокчейна Ethereum
- Перечислить распространённые типы приложений, которые можно разрабатывать на блокчейне Ethereum
- Сравнить и противопоставить разработку в Web2 и Web3
- Сравнить и противопоставить концепцию «владения» в Web2 и Web3

### [Использование газа в транзакциях Ethereum](/learn/introduction-to-ethereum/gas-use-in-eth-transactions)

- Объяснить, что такое газ в Ethereum
- Объяснить, почему газ необходим в Ethereum
- Понимать, как работает газ в транзакциях Ethereum

### [Схема работы EVM](/learn/introduction-to-ethereum/evm-diagram)

- Схема работы EVM

### [Настройка и обзор](/learn/hardhat/hardhat-setup-overview/hardhat-setup-overview-sbs)

- Установить и создать новый проект Hardhat с поддержкой Typescript
- Описать организацию и структуру папок проекта Hardhat
- Перечислить назначение и свойства файла `hardhat.config.ts`

### [Тестирование с Hardhat и Typechain](/learn/hardhat/hardhat-testing/hardhat-testing-sbs)

- Настроить TypeChain для включения тестирования
- Писать модульные тесты для смарт-контрактов с использованием Mocha, Chai и Hardhat Toolkit
- Настраивать несколько подписантов и вызывать функции смарт-контрактов от разных подписантов

### [Etherscan](/learn/hardhat/etherscan/etherscan-sbs)

- Перечислить некоторые функции Etherscan
- Читать данные из контракта Bored Ape Yacht Club на Etherscan
- Записывать данные в контракт с помощью Etherscan.

### [Развертывание смарт-контрактов](/learn/hardhat/hardhat-deploy/hardhat-deploy-sbs)

- Развернуть смарт-контракт в тестовой сети Base Sepolia с помощью `hardhat-deploy`
- Развернуть смарт-контракт в тестовой сети Sepolia с помощью `hardhat-deploy`
- Использовать BaseScan для просмотра развернутого смарт-контракта

### [Верификация смарт-контрактов](/learn/hardhat/hardhat-verify/hardhat-verify-sbs)

- Проверить развернутый смарт-контракт на Etherscan
- Подключить кошелек к контракту в Etherscan
- Использовать Etherscan для взаимодействия с собственным развернутым контрактом

### [Форки в Hardhat](/learn/hardhat/hardhat-forking/hardhat-forking)

- Использовать Hardhat Network для создания локального форка мейннета и развертывания на него контракта
- Использовать возможности форков Hardhat для их настройки под различные сценарии использования

### ['Введение в Remix'](/learn/introduction-to-solidity/introduction-to-remix)

- Перечислить особенности, преимущества и недостатки использования Remix в качестве IDE
- Развернуть и протестировать демо-контракт `Storage.sol` в Remix

### [Развертывание в Remix](/learn/introduction-to-solidity/deployment-in-remix)

- Развернуть и протестировать демо-контракт Storage.sol в Remix

### [Hello World](/learn/contracts-and-basic-functions/hello-world-step-by-step)

- Создать простой контракт "Hello World"
- Перечислить основные различия типов данных в Solidity по сравнению с другими языками
- Выбирать соответствующую видимость для функции

### [Базовые типы](/learn/contracts-and-basic-functions/basic-types)

- Классифицировать базовые типы данных
- Перечислить основные различия типов данных в Solidity по сравнению с другими языками
- Сравнить и противопоставить знаковые и беззнаковые целые числа

### [Тестовые сети](/learn/deployment-to-testnet/test-networks)

- Описать назначение и свойства тестовой сети Base
- Сравнить и противопоставить сети Ropsten, Rinkeby, Goerli и Sepolia

### [Развертывание в Base Sepolia](/learn/deployment-to-testnet/deployment-to-base-sepolia-sbs)

- Развернуть контракт в тестовой сети Base Sepolia и взаимодействовать с ним в [BaseScan]

### [Верификация контракта](/learn/deployment-to-testnet/contract-verification-sbs)

- Проверить контракт в тестовой сети Base Sepolia и взаимодействовать с ним в [BaseScan]

### [Управляющие конструкции](/learn/control-structures/control-structures)

- Управлять потоком выполнения кода с помощью `if`, `else`, `while`, and `for`
- Перечислить уникальные ограничения для управляющих конструкций в Solidity
- Использовать `require` для написания функции, которую можно использовать только когда переменная установлена в `true`
- Написать оператор `revert` для прерывания выполнения функции в определенном состоянии
- Использовать `error` для более эффективного управления потоком, чем с помощью `require`

### [Хранение данных](/learn/storage/simple-storage-sbs)

- Использовать конструктор для инициализации переменной
- Получать доступ к данным публичной переменной с помощью автоматически сгенерированного геттера
- Упорядочивать объявления переменных для эффективного использования хранилища

### [Как работает хранилище](/learn/storage/how-storage-works)

- Составить схему, как данные контракта хранятся в блокчейне (Контракт -> Блокчейн)
- Упорядочивать объявления переменных для эффективного использования хранилища
- Составить схему, как переменные в контракте хранятся в памяти (Переменная -> Контракт)

### [Массивы](/learn/arrays/arrays-in-solidity)

- Описать разницу между массивами в хранилище (storage), памяти (memory) и calldata

### [Фильтрация массива](/learn/arrays/filtering-an-array-sbs)

- Написать функцию, которая может возвращать отфильтрованное подмножество массива

### [Отображения](/learn/mappings/mappings-sbs)

- Создать тип данных Map (словарь)
- Помнить, что присваивание для типа данных Map не такое гибкое, как для других типов данных/в других языках
- Ограничивать вызовы функций с помощью глобальной переменной `msg.sender`
- Помнить об отсутствии защиты от коллизий в EVM и понимать, почему это (вероятно) допустимо

### [Видимость функций и изменяемость состояния](/learn/advanced-functions/function-visibility)

- Классифицировать функции как `public`, `private`, `internal`, или `external` в зависимости от их использования
- Описать, чем функции `pure` и `view` отличаются от функций, изменяющих хранилище

### [Модификаторы функций](/learn/advanced-functions/function-modifiers)

- Использовать модификаторы для эффективного добавления функциональности к нескольким функциям

### [Структуры](/learn/structs/structs-sbs)

- Создать `struct` (пользовательский тип), содержащий несколько различных типов данных
- Объявлять члены `struct` для максимизации эффективности использования хранилища
- Описать ограничения, связанные с присваиванием `struct`, в зависимости от типов, которые они содержат

### [Наследование](/learn/inheritance/inheritance-sbs)

- Написать смарт-контракт, который наследует от другого контракта
- Описать влияние наследования на лимит размера байт-кода

### [Множественное наследование](/learn/inheritance/multiple-inheritance)

- Написать смарт-контракт, который наследует от нескольких контрактов

### [Абстрактные контракты](/learn/inheritance/abstract-contracts-sbs)

- Использовать ключевые слова `virtual`, `override`, и `abstract` ля создания и использования абстрактного контракта

### [Импорты](/learn/imports/imports-sbs)

- Импортировать и использовать код из другого файла
- Использовать контракты OpenZeppelin в Remix

### [Анализ ошибок](/learn/error-triage/error-triage)

- Отлаживать распространенные ошибки Solidity, включая отмену транзакции, нехватку газа, переполнение стека, переполнение/потерю значимости значения, выход индекса за границы и т.д.

### [Ключевое слово New](/learn/new-keyword/new-keyword-sbs)

- Написать контракт, который создает новый контракт с помощью ключевого слова new

### ['Взаимодействие между контрактами'](/learn/interfaces/contract-to-contract-interaction)

- Использовать интерфейсы для того, чтобы смарт-контракт мог вызывать функции в другом смарт-контракте
- Использовать функцию `call()` для взаимодействия с другим контрактом без использования интерфейса

### [События](/learn/events/hardhat-events-sbs)

- Создавать и вызывать событие
- Перечислить распространенные способы использования событий
- Понимать разницу между событиями и хранилищем смарт-контракта

### [Address и Payable в Solidity](/learn/address-and-payable/address-and-payable)

- Различать типы `address` и `address payable` в Solidity
- Определять, когда каждый тип следует использовать в разработке контрактов
- Применять `address payable` для отправки эфира и взаимодействия с payable-функциями

### [Минимальный токен](/learn/token-development/minimal-tokens/minimal-token-sbs)

- Создать минимальный токен и развернуть его в тестовой сети
- Определить свойства, которые делают токен токеном

### [Стандарт токенов ERC-20](/learn/token-development/erc-20-token/erc-20-standard)

- Проанализировать структуру токена ERC-20
- Ознакомиться с формальной спецификацией ERC-20

### [Реализация ERC-20](/learn/token-development/erc-20-token/erc-20-token-sbs)

- Описать OpenZeppelin
- Импортировать реализацию ERC-20 от OpenZeppelin
- Описать разницу между стандартом ERC-20 и реализацией OpenZeppelin ERC20.sol
- Создать и развернуть токен, соответствующий стандарту ERC-20

### [Стандарт токенов ERC-721](/learn/token-development/erc-721-token/erc-721-standard)

- Проанализировать структуру токена ERC-721
- Сравнить и противопоставить технические спецификации ERC-20 и ERC-721
- Ознакомиться с формальной спецификацией ERC-721

### [Токен ERC-721](/learn/token-development/erc-721-token/erc-721-sbs)

- Проанализировать структуру токена ERC-721
- Сравнить и противопоставить технические спецификации ERC-20 и ERC-721
- Ознакомиться с формальной спецификацией ERC-721
- Создать и развернуть токен, соответствующий стандарту ERC-721
- Использовать токен ERC-721 для контроля владения другой структурой данных

### [Коннекторы кошельков](/learn/onchain-app-development/frontend-setup/wallet-connectors)

- Определить роль агрегатора кошельков в ончейн-приложении
- Обсудить преимущества и недостатки использования шаблона
- Создать каркас нового ончейн-приложения с RainbowKit
- Поддерживать пользователей EOA и Coinbase Smart Wallet в одном приложении

### [Создание ончейн-приложения](/learn/onchain-app-development/frontend-setup/building-an-onchain-app)

- Определить роль агрегатора кошельков в ончейн-приложении
- Обсудить преимущества и недостатки использования шаблона
- Добавить подключение кошелька в стандартное приложение-шаблон

### [Хук `useAccount`](/learn/onchain-app-development/reading-and-displaying-data/useAccount)

- Реализовать хук `useAccount` для отображения адреса пользователя, состояния подключения, сети и баланса
- IРеализовать хук `isMounted` для предотвращения ошибок гидратации

### [Хук `useReadContract`](/learn/onchain-app-development/reading-and-displaying-data/useReadContract)

- Реализовать хук `useReadContract` от wagmi для получения данных из смарт-контракта
- Преобразовывать данные, полученные из смарт-контракта, в информацию, отображаемую пользователю
- Определить нюансы чтения данных из автоматически сгенерированных геттеров

### [Настройка `useReadContract`](/learn/onchain-app-development/reading-and-displaying-data/configuring-useReadContract)

- Использовать `useBlockNumber` и `queryClient` для автоматической загрузки обновлений из блокчейна
- Описать затраты на использование вышеуказанного и методы их сокращения
- Настраивать аргументы, передаваемые при вызове `pure` или `view` функции смарт-контракта
- Вызывать экземпляр `useReadContract` по требованию
- Использовать `isLoading` и `isFetching` для улучшения пользовательского опыта

### [Хук `useWriteContract`](/learn/onchain-app-development/writing-to-contracts/useWriteContract)

- Реализовать хук `useWriteContract` от wagmi для отправки транзакций в смарт-контракт
- Настраивать опции в `useWriteContract`
- Отображать выполнение, успех или неудачу функции с помощью изменения состояния кнопки и отображения данных

### [Хук `useSimulateContract`](/learn/onchain-app-development/writing-to-contracts/useSimulateContract)

- Реализовать хуки `useSimulateContract` и `useWriteContract` от wagmi для отправки транзакций в смарт-контракт
- Настраивать опции в `useSimulateContract и useWriteContract`
- Вызывать функцию смарт-контракта по требованию, используя функцию `write` из `useWriteContract`, с аргументами и значением (value)
